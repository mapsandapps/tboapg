// Generated by CoffeeScript 1.7.1
Game.Screen = {};

Game.Screen.startScreen = {
  enter: function() {
    console.log("Entered start screen.");
  },
  exit: function() {
    console.log("Exited start screen.");
  },
  render: function(display) {
    display.drawText(1, 1, "%c{yellow}Codename: The Best of All Possible Games");
    display.drawText(1, 3, "%c{yellow}A CoffeeScript Roguelike by Mollie Taylor");
    display.drawText(1, 5, "Press [Enter] to start!");
  },
  handleInput: function(inputType, inputData) {
    if (inputType === 'keydown') {
      if (inputData.keyCode === ROT.VK_RETURN) {
        Game.switchScreen(Game.Screen.playScreen);
      }
    }
  }
};

Game.Screen.playScreen = {
  _map: null,
  _player: null,
  enter: function() {
    var depth, height, tiles, width;
    width = Game.getScreenWidth();
    height = Game.getScreenHeight();
    depth = 5;
    tiles = new Game.Builder(width, height, depth).getTiles();
    this._player = new Game.Entity(Game.PlayerTemplate);
    this._map = new Game.Map(tiles, this._player);
    this._map.getEngine().start();
  },
  exit: function() {
    console.log("Exited play screen.");
  },
  render: function(display) {
    var background, currentDepth, foreground, glyph, i, items, map, messageY, messages, screenHeight, screenWidth, stats, topLeftX, topLeftY, visibleCells, x, y;
    screenWidth = Game.getScreenWidth();
    screenHeight = Game.getScreenHeight();
    topLeftX = Math.max(0, this._player.getX() - (screenWidth / 2));
    topLeftX = Math.min(topLeftX, this._map.getWidth() - screenWidth);
    topLeftY = Math.max(0, this._player.getY() - (screenHeight / 2));
    topLeftY = Math.min(topLeftY, this._map.getHeight() - screenHeight);
    visibleCells = {};
    map = this._map;
    currentDepth = this._player.getZ();
    this._map.getFov(currentDepth).compute(this._player.getX(), this._player.getY(), this._player.getSightRadius(), function(x, y, radius, visibility) {
      visibleCells[x + ',' + y] = true;
      map.setExplored(x, y, currentDepth, true);
    });
    x = topLeftX;
    while (x < topLeftX + screenWidth) {
      y = topLeftY;
      while (y < topLeftY + screenHeight) {
        if (map.isExplored(x, y, currentDepth)) {
          glyph = this._map.getTile(x, y, currentDepth);
          foreground = glyph.getForeground();
          if (visibleCells[x + "," + y]) {
            items = map.getItemsAt(x, y, currentDepth);
            if (items) {
              glyph = items[items.length - 1];
            }
            if (map.getEntityAt(x, y, currentDepth)) {
              glyph = map.getEntityAt(x, y, currentDepth);
            }
            background = glyph.getBackground();
          } else if (glyph._walkable === false) {
            background = glyph.getBackground();
          } else {
            background = "#1b002e";
          }
          display.draw(x - topLeftX, y - topLeftY, glyph.getChar(), glyph.getForeground(), background);
        }
        y++;
      }
      x++;
    }
    messages = this._player.getMessages();
    messageY = 0;
    i = 0;
    while (i < messages.length) {
      messageY += display.drawText(0, messageY, '%c{white}%b{black}' + messages[i]);
      i++;
    }
    stats = '%c{white}%b{black}';
    stats += vsprintf('HP: %d/%d ', [this._player.getHp(), this._player.getMaxHp()]);
    display.drawText(0, screenHeight, stats);
  },
  handleInput: function(inputType, inputData) {
    var currentZ, newZ;
    if (this._gameEnded) {
      if (inputType === 'keydown' && inputData.keyCode === ROT.VK_RETURN) {
        Game.switchScreen(Game.Screen.loseScreen);
      }
      return;
    }
    if (inputType === 'keydown') {
      if (inputData.keyCode === ROT.VK_RETURN) {
        Game.switchScreen(Game.Screen.winScreen);
      } else if (inputData.keyCode === ROT.VK_ESCAPE) {
        Game.switchScreen(Game.Screen.loseScreen);
      } else {
        if (inputData.keyCode === ROT.VK_LEFT) {
          this.move(-1, 0, 0);
        } else if (inputData.keyCode === ROT.VK_RIGHT) {
          this.move(1, 0, 0);
        } else if (inputData.keyCode === ROT.VK_UP) {
          this.move(0, -1, 0);
        } else if (inputData.keyCode === ROT.VK_DOWN) {
          this.move(0, 1, 0);
        } else if (inputData.keyCode === ROT.VK_D) {
          currentZ = this._player.getZ();
          this._player.tryMove(upLoc[currentZ].x, upLoc[currentZ].y, upLoc[currentZ].z, this._map);
        } else if (inputData.keyCode === ROT.VK_U) {
          newZ = this._player.getZ() - 1;
          this._player.tryMove(downLoc[newZ].x, downLoc[newZ].y, downLoc[newZ].z, this._map);
        } else {
          return;
        }
        this._map.getEngine().unlock();
      }
    }
  },
  move: function(dX, dY, dZ) {
    var newX, newY, newZ;
    newX = this._player.getX() + dX;
    newY = this._player.getY() + dY;
    newZ = this._player.getZ() + dZ;
    this._player.tryMove(newX, newY, newZ, this._map);
  },
  setGameEnded: function(gameEnded) {
    this._gameEnded = gameEnded;
  }
};

Game.Screen.winScreen = {
  enter: function() {
    console.log("Entered win screen.");
  },
  exit: function() {
    console.log("Exited win screen.");
  },
  render: function(display) {
    var b, background, g, i, r, _i;
    for (i = _i = 0; _i <= 23; i = ++_i) {
      r = Math.round(Math.random() * 255);
      g = Math.round(Math.random() * 255);
      b = Math.round(Math.random() * 255);
      background = ROT.Color.toRGB([r, g, b]);
      display.drawText(2, i + 1, "%b{" + background + "}You win!");
    }
  },
  handleInput: function(inputType, inputData) {}
};

Game.Screen.loseScreen = {
  enter: function() {
    console.log("Entered lose screen.");
  },
  exit: function() {
    console.log("Exited lose screen.");
  },
  render: function(display) {
    var i, _i, _len, _ref;
    _ref = [
      {
        0: 23
      }
    ];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      i = _ref[_i];
      display.drawText(2, i + 1, "%b{red}You lose! :(");
    }
  },
  handleInput: function(inputType, inputData) {}
};
