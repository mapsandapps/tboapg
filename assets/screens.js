// Generated by CoffeeScript 1.7.1
Game.Screen = {};

Game.Screen.startScreen = {
  enter: function() {
    console.log("Entered start screen.");
  },
  exit: function() {
    console.log("Exited start screen.");
  },
  render: function(display) {
    display.drawText(1, 1, "%c{yellow}Five: A CoffeeScript Roguelike by Mollie Taylor");
    display.drawText(1, 3, "Press [Enter] to start!");
  },
  handleInput: function(inputType, inputData) {
    if (inputType === 'keydown') {
      if (inputData.keyCode === ROT.VK_RETURN) {
        Game.switchScreen(Game.Screen.playScreen);
      }
    }
  }
};

Game.Screen.playScreen = {
  _map: null,
  _player: null,
  _gameEnded: false,
  _subScreen: null,
  enter: function() {
    var depth, height, tiles, width;
    width = Game.getScreenWidth();
    height = Game.getScreenHeight();
    depth = 5;
    tiles = new Game.Builder(width, height, depth).getTiles();
    this._player = new Game.Entity(Game.PlayerTemplate);
    this._map = new Game.Map(tiles, this._player);
    this._map.getEngine().start();
  },
  exit: function() {
    console.log("Exited play screen.");
  },
  render: function(display) {
    var background, currentDepth, foreground, glyph, i, items, map, messageY, messages, screenHeight, screenWidth, stats, topLeftX, topLeftY, visibleCells, x, y;
    if (this._subScreen) {
      this._subScreen.render(display);
      return;
    }
    screenWidth = Game.getScreenWidth();
    screenHeight = Game.getScreenHeight();
    topLeftX = Math.max(0, this._player.getX() - (screenWidth / 2));
    topLeftX = Math.min(topLeftX, this._map.getWidth() - screenWidth);
    topLeftY = Math.max(0, this._player.getY() - (screenHeight / 2));
    topLeftY = Math.min(topLeftY, this._map.getHeight() - screenHeight);
    visibleCells = {};
    map = this._map;
    currentDepth = this._player.getZ();
    this._map.getFov(currentDepth).compute(this._player.getX(), this._player.getY(), this._player.getSightRadius(), function(x, y, radius, visibility) {
      visibleCells[x + ',' + y] = true;
      map.setExplored(x, y, currentDepth, true);
    });
    x = topLeftX;
    while (x < topLeftX + screenWidth) {
      y = topLeftY;
      while (y < topLeftY + screenHeight) {
        if (map.isExplored(x, y, currentDepth)) {
          glyph = this._map.getTile(x, y, currentDepth);
          foreground = glyph.getForeground();
          if (visibleCells[x + "," + y]) {
            items = map.getItemsAt(x, y, currentDepth);
            if (items) {
              glyph = items[items.length - 1];
            }
            if (map.getEntityAt(x, y, currentDepth)) {
              glyph = map.getEntityAt(x, y, currentDepth);
            }
            background = glyph.getBackground();
          } else if (glyph._walkable === false) {
            background = glyph.getBackground();
          } else {
            background = "#1b002e";
          }
          display.draw(x - topLeftX, y - topLeftY, glyph.getChar(), glyph.getForeground(), background);
        }
        y++;
      }
      x++;
    }
    messages = this._player.getMessages();
    messageY = 0;
    i = 0;
    while (i < messages.length) {
      messageY += display.drawText(0, messageY, '%c{white}%b{black}' + messages[i]);
      i++;
    }
    stats = '%c{white}%b{black}';
    stats += vsprintf('HP: %d/%d ', [this._player.getHp(), this._player.getMaxHp()]);
    display.drawText(0, screenHeight, stats);
  },
  handleInput: function(inputType, inputData) {
    var currentZ, item, items, newZ;
    if (this._gameEnded) {
      if (inputType === 'keydown' && inputData.keyCode === ROT.VK_RETURN) {
        Game.switchScreen(Game.Screen.loseScreen);
      }
      return;
    }
    if (this._subScreen) {
      this._subScreen.handleInput(inputType, inputData);
      return;
    }
    if (inputType === 'keydown') {
      if (inputData.keyCode === ROT.VK_RETURN) {
        Game.switchScreen(Game.Screen.winScreen);
      } else if (inputData.keyCode === ROT.VK_ESCAPE) {
        Game.switchScreen(Game.Screen.loseScreen);
      } else {
        if (inputData.keyCode === ROT.VK_LEFT) {
          this.move(-1, 0, 0);
        } else if (inputData.keyCode === ROT.VK_RIGHT) {
          this.move(1, 0, 0);
        } else if (inputData.keyCode === ROT.VK_UP) {
          this.move(0, -1, 0);
        } else if (inputData.keyCode === ROT.VK_DOWN) {
          this.move(0, 1, 0);
        } else if (inputData.keyCode === ROT.VK_D) {
          currentZ = this._player.getZ();
          if (currentZ >= this._map.getDepth() - 1) {
            Game.sendMessage(this._player, "You can't go down here!");
          } else {
            this._player.tryMove(upLoc[currentZ].x, upLoc[currentZ].y, upLoc[currentZ].z, this._map);
          }
        } else if (inputData.keyCode === ROT.VK_U) {
          newZ = this._player.getZ() - 1;
          if (newZ > 0) {
            this._player.tryMove(downLoc[newZ].x, downLoc[newZ].y, newZ, this._map);
          } else {
            Game.sendMessage(this._player, "You can't go up here!");
          }
        } else if (inputData.keyCode === ROT.VK_I) {
          this.showItemsSubScreen(Game.Screen.inventoryScreen, this._player.getItems(), 'You are not carrying anything.');
          return;
        } else if (inputData.keyCode === ROT.VK_W) {
          if (inputData.shiftKey) {
            this.showItemsSubScreen(Game.Screen.wearScreen, this._player.getItems(), 'You have nothing to wear.');
          } else {
            this.showItemsSubScreen(Game.Screen.wieldScreen, this._player.getItems(), 'You have nothing to wield.');
          }
          return;
        } else if (inputData.keyCode === ROT.VK_COMMA) {
          items = this._map.getItemsAt(this._player.getX(), this._player.getY(), this._player.getZ());
          if (!items) {
            Game.sendMessage(this._player('There is nothing here to pick up.'));
          } else if (items.length === 1) {
            item = items[0];
            if (this._player.pickupItems([0])) {
              Game.sendMessage(this._player, "You pick up %s. You can press 'w' to wield it.", [item.describeA()]);
            } else {
              Game.sendMessage(this._player, 'Your inventory is full! Nothing was picked up.');
            }
          } else {
            this.showItemsSubScreen(Game.Screen.pickupScreen, items, 'There is nothing here to pick up.');
            return;
          }
        } else {
          return;
        }
        this._map.getEngine().unlock();
      }
    }
  },
  move: function(dX, dY, dZ) {
    var newX, newY, newZ;
    newX = this._player.getX() + dX;
    newY = this._player.getY() + dY;
    newZ = this._player.getZ() + dZ;
    this._player.tryMove(newX, newY, newZ, this._map);
  },
  setGameEnded: function(gameEnded) {
    this._gameEnded = gameEnded;
  },
  setSubScreen: function(subScreen) {
    this._subScreen = subScreen;
    Game.refresh();
  },
  showItemsSubScreen: function(subScreen, items, emptyMessage) {
    if (items && subScreen.setup(this._player, items) > 0) {
      this.setSubScreen(subScreen);
    } else {
      Game.sendMessage(this._player, emptyMessage);
      Game.refresh();
    }
  }
};

Game.Screen.winScreen = {
  enter: function() {
    console.log("Entered win screen.");
  },
  exit: function() {
    console.log("Exited win screen.");
  },
  render: function(display) {
    var b, background, g, i, r, _i;
    for (i = _i = 0; _i <= 23; i = ++_i) {
      r = Math.round(Math.random() * 255);
      g = Math.round(Math.random() * 255);
      b = Math.round(Math.random() * 255);
      background = ROT.Color.toRGB([r, g, b]);
      display.drawText(2, i + 1, "%b{" + background + "}You win!");
    }
  },
  handleInput: function(inputType, inputData) {}
};

Game.Screen.loseScreen = {
  enter: function() {
    console.log("Entered lose screen.");
  },
  exit: function() {
    console.log("Exited lose screen.");
  },
  render: function(display) {
    var i, _i;
    for (i = _i = 0; _i <= 23; i = ++_i) {
      display.drawText(2, i + 1, "%b{red}You lose! :(");
    }
  },
  handleInput: function(inputType, inputData) {}
};

Game.Screen.ItemListScreen = function(template) {
  this._caption = template['caption'];
  this._okFunction = template['ok'];
  this._isAcceptableFunction = template['isAcceptable'] || function(x) {
    return x;
  };
  this._canSelectItem = template['canSelect'];
  this._canSelectMultipleItems = template['canSelectMultipleItems'];
  this._hasNoItemOption = template['hasNoItemOption'];
};

Game.Screen.ItemListScreen.prototype.setup = function(player, items) {
  var count, that;
  this._player = player;
  count = 0;
  that = this;
  this._items = items.map(function(item) {
    if (that._isAcceptableFunction(item)) {
      count++;
      return item;
    } else {
      return null;
    }
  });
  this._selectedIndices = {};
  return count;
};

Game.Screen.ItemListScreen.prototype.render = function(display) {
  var i, letter, letters, row, selectionState, suffix;
  letters = 'vwxyz';
  display.drawText(0, 0, this._caption);
  if (this._hasNoItemOption) {
    display.drawText(0, 1, '0 - no item');
  }
  row = 0;
  i = 0;
  while (i < this._items.length) {
    if (this._items[i]) {
      letter = letters.substring(i, i + 1);
      selectionState = (this._canSelectItem && this._canSelectMultipleItems && this._selectedIndices[i] ? '+' : '-');
      suffix = '';
      if (this._items[i] === this._player.getArmor()) {
        suffix = ' (wearing)';
      }
      if (this._items[i] === this._player.getWeapon()) {
        suffix = ' (wielding)';
      }
      display.drawText(0, 2 + row, letter + ' ' + selectionState + ' ' + this._items[i].describe());
      row++;
    }
    i++;
  }
};

Game.Screen.ItemListScreen.prototype.executeOkFunction = function() {
  var key, selectedItems;
  selectedItems = {};
  for (key in this._selectedIndices) {
    selectedItems[key] = this._items[key];
  }
  Game.Screen.playScreen.setSubScreen(undefined);
  if (this._okFunction(selectedItems)) {
    this._player.getMap().getEngine().unlock();
  }
};

Game.Screen.ItemListScreen.prototype.handleInput = function(inputType, inputData) {
  var index;
  if (inputType === "keydown") {
    if (inputData.keyCode === ROT.VK_ESCAPE || (inputData.keyCode === ROT.VK_RETURN && (!this._canSelectItem || Object.keys(this._selectedIndices).length === 0))) {
      Game.Screen.playScreen.setSubScreen(undefined);
    } else if (inputData.keyCode === ROT.VK_RETURN) {
      this.executeOkFunction();
    } else if (this._canSelectItem && this._hasNoItemOption && inputData.keyCode === ROT.VK_0) {
      this._selectedIndices = {};
      this.executeOkFunction();
    } else if (this._canSelectItem && inputData.keyCode >= ROT.VK_V && inputData.keyCode <= ROT.VK_Z) {
      index = inputData.keyCode - ROT.VK_V;
      if (this._items[index]) {
        if (this._canSelectMultipleItems) {
          if (this._selectedIndices[index]) {
            delete this._selectedIndices[index];
          } else {
            this._selectedIndices[index] = true;
          }
          Game.refresh();
        } else {
          this._selectedIndices[index] = true;
          this.executeOkFunction();
        }
      }
    }
  }
};

Game.Screen.inventoryScreen = new Game.Screen.ItemListScreen({
  caption: "Inventory",
  canSelect: false
});

Game.Screen.pickupScreen = new Game.Screen.ItemListScreen({
  caption: "Choose the items you wish to pickup",
  canSelect: true,
  canSelectMultipleItems: true,
  ok: function(selectedItems) {
    if (!this._player.pickupItems(Object.keys(selectedItems))) {
      Game.sendMessage(this._player, "Your inventory is full! Not all items were picked up.");
    }
    return true;
  }
});

Game.Screen.dropScreen = new Game.Screen.ItemListScreen({
  caption: "Choose the item you wish to drop",
  canSelect: true,
  canSelectMultipleItems: false,
  ok: function(selectedItems) {
    this._player.dropItem(Object.keys(selectedItems)[0]);
    return true;
  }
});

Game.Screen.wieldScreen = new Game.Screen.ItemListScreen({
  caption: 'Choose the item you wish to wield',
  canSelect: true,
  canSelectMultipleItems: false,
  hasNoItemOption: true,
  isAcceptable: function(item) {
    return item && item.hasMixin('Equippable') && item.isWieldable();
  },
  ok: function(selectedItems) {
    var item, keys;
    keys = Object.keys(selectedItems);
    if (keys.length === 0) {
      this._player.unwield();
      Game.sendMessage(this._player, 'You are empty handed.');
    } else {
      item = selectedItems[keys[0]];
      this._player.unequip(item);
      this._player.wield(item);
      Game.sendMessage(this._player, 'You are wielding %s.', [item.describeA()]);
    }
    return true;
  }
});

Game.Screen.wearScreen = new Game.Screen.ItemListScreen({
  caption: 'Choose the item you wish to wear',
  canSelect: true,
  canSelectMultipleItems: false,
  hasNoItemOption: true,
  isAcceptable: function(item) {
    return item && item.hasMixin('Equippable') && item.isWearable();
  },
  ok: function(selectedItems) {
    var item, keys;
    keys = Object.keys(selectedItems);
    if (keys.length === 0) {
      this._player.unwield();
      Game.sendMessage(this._player, 'You are not wearing anything.');
    } else {
      item = selectedItems[keys[0]];
      this._player.unequip(item);
      this._player.wear(item);
      Game.sendMessage(this._player, 'You are wearing %s.', [item.describeA()]);
    }
    return true;
  }
});
