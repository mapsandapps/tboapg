// Generated by CoffeeScript 1.7.1
Game.Screen = {};

Game.Screen.startScreen = {
  enter: function() {
    console.log("Entered start screen.");
  },
  exit: function() {
    console.log("Exited start screen.");
  },
  render: function(display) {
    display.drawText(1, 1, "%c{yellow}CoffeeScript Roguelike");
    display.drawText(1, 2, "Press [Enter] to start!");
  },
  handleInput: function(inputType, inputData) {
    if (inputType === 'keydown') {
      if (inputData.keyCode === ROT.VK_RETURN) {
        Game.switchScreen(Game.Screen.playScreen);
      }
    }
  }
};

Game.Screen.playScreen = {
  _map: null,
  _player: null,
  enter: function() {
    var generator, i, map, mapHeight, mapWidth, totalIterations, x, y;
    map = [];
    mapWidth = 500;
    mapHeight = 500;
    x = 0;
    while (x < mapWidth) {
      map.push([]);
      y = 0;
      while (y < mapHeight) {
        map[x].push(Game.Tile.nullTile);
        y++;
      }
      x++;
    }
    generator = new ROT.Map.Cellular(mapWidth, mapHeight);
    generator.randomize(0.5);
    totalIterations = 3;
    i = 0;
    while (i < totalIterations - 1) {
      generator.create();
      i++;
    }
    generator.create(function(x, y, v) {
      if (v === 1) {
        map[x][y] = Game.Tile.floorTile;
      } else {
        map[x][y] = Game.Tile.wallTile;
      }
    });
    this._player = new Game.Entity(Game.PlayerTemplate);
    this._map = new Game.Map(map, this._player);
    this._map.getEngine().start();
  },
  exit: function() {
    console.log("Exited play screen.");
  },
  render: function(display) {
    var entities, entity, i, messageY, messages, screenHeight, screenWidth, stats, tile, topLeftX, topLeftY, x, y;
    screenWidth = Game.getScreenWidth();
    screenHeight = Game.getScreenHeight();
    topLeftX = Math.max(0, this._player.getX() - (screenWidth / 2));
    topLeftX = Math.min(topLeftX, this._map.getWidth() - screenWidth);
    topLeftY = Math.max(0, this._player.getY() - (screenHeight / 2));
    topLeftY = Math.min(topLeftY, this._map.getHeight() - screenHeight);
    x = topLeftX;
    while (x < topLeftX + screenWidth) {
      y = topLeftY;
      while (y < topLeftY + screenHeight) {
        tile = this._map.getTile(x, y);
        display.draw(x - topLeftX, y - topLeftY, tile.getChar(), tile.getForeground(), tile.getBackground());
        y++;
      }
      x++;
    }
    entities = this._map.getEntities();
    i = 0;
    while (i < entities.length) {
      entity = entities[i];
      if (entity.getX() >= topLeftX && entity.getY() >= topLeftY && entity.getX() < topLeftX + screenWidth && entity.getY() < topLeftY + screenHeight) {
        display.draw(entity.getX() - topLeftX, entity.getY() - topLeftY, entity.getChar(), entity.getForeground(), entity.getBackground());
      }
      i++;
    }
    messages = this._player.getMessages();
    messageY = 0;
    i = 0;
    while (i < messages.length) {
      messageY += display.drawText(0, messageY, '%c{white}%b{black}' + messages[i]);
      i++;
    }
    stats = '%c{white}%b{black}';
    stats += vsprintf('HP: %d/%d ', [this._player.getHp(), this._player.getMaxHp()]);
    display.drawText(0, screenHeight, stats);
  },
  handleInput: function(inputType, inputData) {
    if (inputType === 'keydown') {
      if (inputData.keyCode === ROT.VK_RETURN) {
        Game.switchScreen(Game.Screen.winScreen);
      } else if (inputData.keyCode === ROT.VK_ESCAPE) {
        Game.switchScreen(Game.Screen.loseScreen);
      }
      if (inputData.keyCode === ROT.VK_LEFT) {
        this.move(-1, 0);
      } else if (inputData.keyCode === ROT.VK_RIGHT) {
        this.move(1, 0);
      } else if (inputData.keyCode === ROT.VK_UP) {
        this.move(0, -1);
      } else if (inputData.keyCode === ROT.VK_DOWN) {
        this.move(0, 1);
      }
      this._map.getEngine().unlock();
    }
  },
  move: function(dX, dY) {
    var newX, newY;
    newX = this._player.getX() + dX;
    newY = this._player.getY() + dY;
    this._player.tryMove(newX, newY, this._map);
  }
};

Game.Screen.winScreen = {
  enter: function() {
    console.log("Entered win screen.");
  },
  exit: function() {
    console.log("Exited win screen.");
  },
  render: function(display) {
    var b, background, g, i, r, _i;
    for (i = _i = 0; _i <= 23; i = ++_i) {
      r = Math.round(Math.random() * 255);
      g = Math.round(Math.random() * 255);
      b = Math.round(Math.random() * 255);
      background = ROT.Color.toRGB([r, g, b]);
      display.drawText(2, i + 1, "%b{" + background + "}You win!");
    }
  },
  handleInput: function(inputType, inputData) {}
};

Game.Screen.loseScreen = {
  enter: function() {
    console.log("Entered lose screen.");
  },
  exit: function() {
    console.log("Exited lose screen.");
  },
  render: function(display) {
    var i, _i, _len, _ref;
    _ref = [
      {
        0: 23
      }
    ];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      i = _ref[_i];
      display.drawText(2, i + 1, "%b{red}You lose! :(");
    }
  },
  handleInput: function(inputType, inputData) {}
};
